# -*- coding: utf-8 -*-
"""TAREA BIO 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vkC9s4Cm6p9ah2fXajQacf0EiEDETtWW

#***Librerias y dataset***
"""

# Commented out IPython magic to ensure Python compatibility.
# %config IPCompleter.greedy=True
from google.colab import drive
drive.mount('/content/drive')
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.ticker import PercentFormatter
import os
import zipfile
!pip install scipy
from scipy.signal import find_peaks
from scipy import signal as sg

from google.colab import drive
drive.mount('/content/drive')

# Ruta donde está el archivo ZIP subido
zip_path = '/content/drive/MyDrive/TAREABIO2/mit-bih-arrhythmia-database-p-wave-annotations-1.0.0.zip'
extract_dir = '/content/dataset/'

# Crear el directorio si no existe
if not os.path.exists(extract_dir):
    os.makedirs(extract_dir)

# Extraer el ZIP
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_dir)

print(f"Contenido extraído en {extract_dir}")

!pip install wfdb
import wfdb # after installation, import the module

data_dir = '/content/drive/MyDrive/TAREABIO2/mit-bih-arrhythmia-database-p-wave-annotations-1.0.0'
filename = os.path.join(data_dir, '100')

#Rango específico de muestras
record = wfdb.rdrecord(filename, sampfrom=180, sampto=4000)
annotation = wfdb.rdann(filename, 'dat', sampfrom=180, sampto=4000, shift_samps=True)
#Graficar la señal con las anotaciones
wfdb.plot_wfdb(record=record, annotation=annotation, time_units='seconds', figsize=(15,8))

"""#***DETECCION DEL QRS***

El filtro pasa banda se utiliza para atenuar el ruido en la señal de entrada.
Para lograr una banda de paso de 5-15 Hz, la señal de entrada primero pasa
por un filtro pasa bajos con una frecuencia de corte de 11 Hz y luego por un filtro pasa altos con una frecuencia de corte de 5 Hz, lograndolos umbrales requeridos.

    La ecuación recursiva del filtro pasa bajos es:
      y(nT) = 2y(nT - T) - y(nT - 2T) + x(nT) - 2x(nT - 6T) + x(nT - 12T)

    La ecuación recursiva del filtro pasa altos es:
      y(nT) = 32x(nT - 16T) - y(nT - T) - x(nT) + x(nT - 32T)

Se toma la derivada de la señal de entrada para obtener información sobre la pendiente de la señal. De este modo, se obtiene la tasa de cambio de la entrada en este paso del algoritmo.

    La ecuación recursiva del filtro derivativo es:
      y(nT) = [-x(nT - 2T) - 2x(nT - T) + 2x(nT + T) + x(nT + 2T)]/(8T)

El proceso de elevar al cuadrado se utiliza para intensificar la pendiente de la curva de respuesta en frecuencia obtenida en el paso de la derivada.Este paso ayuda a reducir falsos positivos que pueden ser causados por ondas T en la señal de entrada.

    La ecuación recursiva del filtro de elevación al cuadrado es:
      y(nT) = [x(nT)]^2

El proceso de integración con ventana móvil se realiza para obtener
información tanto de la pendiente como del ancho del complejo QRS. Se usa un tamaño de ventana de 0.15*(frecuencia de muestreo) para obtener resultados más precisos.

    La ecuación recursiva de la integración de ventana móvil es:
      y(nT) = [y(nT - (N-1)T) + x(nT - (N-2)T) + ... + x(nT)]/N

donde N es el número de muestras en el ancho de la ventana de integración.

El algoritmo de detección de picos funciona en la señal filtrada y con ventana móvil. Entonces, la señal de entrada se pasa primero por el filtro pasa banda, luego el resultado de este se da a la función derivativa, y el resultado se eleva al cuadrado. Finalmente, el resultado del proceso de elevar al cuadrado se pasa a la función de integración de ventana móvil y se retorna.
"""

class Pan_Tompkins_QRS():

  def filtro_pasa_banda(self, señal):
    # Inicializar el resultado
    resultado = None

    # Crear una copia de la señal de entrada
    sig = señal.copy()

    # Aplicar el filtro pasa bajos usando la ecuación dada
    for index in range(len(señal)):
      sig[index] = señal[index]

      if (index >= 1):
        sig[index] += 2*sig[index-1]

      if (index >= 2):
        sig[index] -= sig[index-2]

      if (index >= 6):
        sig[index] -= 2*señal[index-6]

      if (index >= 12):
        sig[index] += señal[index-12]

    # Copiar el resultado del filtro pasa bajos
    resultado = sig.copy()

    # Aplicar el filtro pasa altos usando la ecuación dada
    for index in range(len(señal)):
      resultado[index] = -1*sig[index]

      if (index >= 1):
        resultado[index] -= resultado[index-1]

      if (index >= 16):
        resultado[index] += 32*sig[index-16]

      if (index >= 32):
        resultado[index] += sig[index-32]

    # Normalizar el resultado del filtro pasa altos
    max_val = max(max(resultado), -min(resultado))
    resultado = resultado/max_val

    return resultado

  def derivada(self, señal):
    # Inicializar el resultado
    resultado = señal.copy()

    # Aplicar el filtro derivativo usando la ecuación dada
    for index in range(len(señal)):
      resultado[index] = 0

      if (index >= 1):
        resultado[index] -= 2*señal[index-1]

      if (index >= 2):
        resultado[index] -= señal[index-2]

      if (index >= 2 and index <= len(señal)-2):
        resultado[index] += 2*señal[index+1]

      if (index >= 2 and index <= len(señal)-3):
        resultado[index] += señal[index+2]

      resultado[index] = (resultado[index]*annotation.fs)/8

    return resultado

  def cuadrado(self, señal):
    # Inicializar el resultado
    resultado = señal.copy()

    # Aplicar el proceso de elevar al cuadrado usando la ecuación dada
    for index in range(len(señal)):
      resultado[index] = señal[index]**2

    return resultado

  def integración_ventana_móvil(self, señal):
    # Inicializar el resultado y el tamaño de la ventana para la integración
    resultado = señal.copy()
    tamaño_ventana = round(0.150 * annotation.fs)
    suma = 0

    # Calcular la suma para los primeros N términos
    for j in range(tamaño_ventana):
      suma += señal[j]/tamaño_ventana
      resultado[j] = suma

    # Aplicar la integración de ventana móvil usando la ecuación dada
    for index in range(tamaño_ventana, len(señal)):
      suma += señal[index]/tamaño_ventana
      suma -= señal[index-tamaño_ventana]/tamaño_ventana
      resultado[index] = suma

    return resultado

  def resolver(self, señal):
    # Convertir la señal de entrada a un array de numpy
    señal_entrada = señal.iloc[:,1].to_numpy()

    # Filtro Pasa Banda
    global pasa_banda
    pasa_banda = self.filtro_pasa_banda(señal_entrada.copy())

    # Función Derivativa
    global derivada
    derivada = self.derivada(pasa_banda.copy())

    # Función de Elevar al Cuadrado
    global cuadrado
    cuadrado = self.cuadrado(derivada.copy())

    # Función de Integración de Ventana Móvil
    global ventana_móvil
    ventana_móvil = self.integración_ventana_móvil(cuadrado.copy())

    return ventana_móvil

# Instanciar el detector de QRS
detector_QRS = Pan_Tompkins_QRS()

# Crear un DataFrame con los datos del ECG
ecg = pd.DataFrame(np.array([list(range(len(record.adc()))), record.adc()[:,0]]).T, columns=['MarcaTemporal', 'ecg'])

# Resolver la señal usando el detector de QRS
señal_salida = detector_QRS.resolver(ecg)

# Graficar la señal filtrada por el paso de banda
plt.figure(figsize = (20,4), dpi = 100)
plt.xticks(np.arange(0, len(pasa_banda)+1, 150))
plt.plot(pasa_banda[32:len(pasa_banda)-2])
plt.xlabel('Muestras')
plt.ylabel('MLIImV')
plt.title("Señal Filtrada por el Paso de Banda")

# Graficar la señal derivada
plt.figure(figsize = (20,4), dpi = 100)
plt.xticks(np.arange(0, len(derivada)+1, 150))
plt.plot(derivada[32:len(derivada)-2])
plt.xlabel('Muestras')
plt.ylabel('MLIImV')
plt.title("Señal Derivada")

# Graficar la señal al cuadrado
plt.figure(figsize = (20,4), dpi = 100)
plt.xticks(np.arange(0, len(cuadrado)+1, 150))
plt.plot(cuadrado[32:len(cuadrado)-2])
plt.xlabel('Muestras')
plt.ylabel('MLIImV')
plt.title("Señal Elevada al Cuadrado")

# Graficar la señal integrada
plt.figure(figsize = (20,4), dpi = 100)
plt.xticks(np.arange(0, len(ventana_móvil)+1, 150))
plt.plot(ventana_móvil[100:len(ventana_móvil)-2])
plt.xlabel('Muestras')
plt.ylabel('MLIImV')
plt.title("Señal Integrada")

"""#***CALCULO DE FRECUENCIA CARDIACA***"""

class frecuencia_cardiaca():

  def __init__(self, senal, frec_muestreo):

    # Inicializar variables
    self.RR1, self.RR2, self.picos_probables, self.r_locs, self.picos, self.resultado = ([] for i in range(6))
    self.SPKI, self.NPKI, self.Umbral_I1, self.Umbral_I2, self.SPKF, self.NPKF, self.Umbral_F1, self.Umbral_F2 = (0 for i in range(8))

    self.onda_T = False
    self.ventana_mov = ventana_móvil
    self.pasa_banda = pasa_banda
    self.frec_muestreo = frec_muestreo
    self.senal = senal
    self.ventana_150ms = round(0.15*self.frec_muestreo)

    self.Limite_Bajo_RR = 0
    self.Limite_Alto_RR = 0
    self.Limite_RR_Perdido = 0
    self.Promedio_RR1 = 0


  def aproximar_picos(self):
    '''
    Aproximar ubicaciones de picos
    '''

    # Convolución FFT
    pendientes = sg.fftconvolve(self.ventana_mov, np.full((25,), 1) / 25, mode='same')

    # Encontrar ubicaciones aproximadas de los picos
    for i in range(round(0.5*self.frec_muestreo) + 1, len(pendientes)-1):
        if (pendientes[i] > pendientes[i-1]) and (pendientes[i+1] < pendientes[i]):
            self.picos.append(i)


  def ajustar_intervalo_rr(self,ind):
    '''
    Ajustar el intervalo RR y los límites
    :param ind: índice actual en el array de picos
    '''

    # Encontrar los ocho intervalos RR más recientes
    self.RR1 = np.diff(self.picos[max(0, ind - 8) : ind + 1])/self.frec_muestreo

    # Calcular promedios RR
    self.Promedio_RR1 = np.mean(self.RR1)
    Promedio_RR2 = self.Promedio_RR1

    # Encontrar los ocho intervalos RR más recientes entre el Limite Bajo RR y el Limite Alto RR
    if (ind >= 8):
        for i in range(0, 8):
            if (self.Limite_Bajo_RR < self.RR1[i] < self.Limite_Alto_RR):
                self.RR2.append(self.RR1[i])

                if (len(self.RR2) > 8):
                    self.RR2.remove(self.RR2[0])
                    Promedio_RR2 = np.mean(self.RR2)

    # Ajustar el Limite Bajo RR y el Limite Alto RR
    if (len(self.RR2) > 7 or ind < 8):
        self.Limite_Bajo_RR = 0.92 * Promedio_RR2
        self.Limite_Alto_RR = 1.16 * Promedio_RR2
        self.Limite_RR_Perdido = 1.66 * Promedio_RR2


  def retroceso(self, valor_pico, RRn, ventana_retroceso):
      '''
      Retroceso
      :param valor_pico: ubicación del pico en consideración
      :param RRn: el intervalo RR más reciente
      :param ventana_retroceso: ventana de retroceso
      '''

      # Verificar si el intervalo RR más reciente es mayor que el límite RR perdido
      if (RRn > self.Limite_RR_Perdido):
          # Inicializar una ventana para retroceder
          ventana_rr = self.ventana_mov[valor_pico - ventana_retroceso + 1 : valor_pico + 1]

          # Encontrar las ubicaciones x dentro de la ventana con valores y mayores que el Umbral I1
          coord = np.asarray(ventana_rr > self.Umbral_I1).nonzero()[0]

          # Encontrar la ubicación x del valor máximo del pico en la ventana de búsqueda
          if (len(coord) > 0):
              for pos in coord:
                  if (ventana_rr[pos] == max(ventana_rr[coord])):
                      x_max = pos
                      break
          else:
            x_max = None

          # Si se encuentra el valor máximo del pico
          if (x_max is not None):
            # Actualizar los umbrales correspondientes a la integración de la ventana móvil
            self.SPKI = 0.25 * self.ventana_mov[x_max] + 0.75 * self.SPKI
            self.Umbral_I1 = self.NPKI + 0.25 * (self.SPKI - self.NPKI)
            self.Umbral_I2 = 0.5 * self.Umbral_I1

            # Inicializar una ventana para retroceder
            ventana_rr = self.pasa_banda[x_max - self.ventana_150ms: min(len(self.pasa_banda) -1, x_max)]

            # Encontrar las ubicaciones x dentro de la ventana con valores y mayores que el Umbral F1
            coord = np.asarray(ventana_rr > self.Umbral_F1).nonzero()[0]

            # Encontrar la ubicación x del valor máximo del pico en la ventana de búsqueda
            if (len(coord) > 0):
              for pos in coord:
                  if (ventana_rr[pos] == max(ventana_rr[coord])):
                      r_max = pos
                      break
            else:
              r_max = None

            # Si se encuentra el valor máximo del pico
            if (r_max is not None):
              # Actualizar los umbrales correspondientes al filtro pasa-banda
              if self.pasa_banda[r_max] > self.Umbral_F2:
                  self.SPKF = 0.25 * self.pasa_banda[r_max] + 0.75 * self.SPKF
                  self.Umbral_F1 = self.NPKF + 0.25 * (self.SPKF - self.NPKF)
                  self.Umbral_F2 = 0.5 * self.Umbral_F1

                  # Agregar la ubicación probable del pico R
                  self.r_locs.append(r_max)


  def identificar_onda_t(self, valor_pico, RRn, ind, ind_prev):
    '''
    Identificación de la Onda T
    :param valor_pico: ubicación del pico en consideración
    :param RRn: el intervalo RR más reciente
    :param ind: índice actual en el array de picos
    :param ind_prev: índice anterior en el array de picos
    '''

    if (self.ventana_mov[valor_pico] >= self.Umbral_I1):
        if (ind > 0 and 0.20 < RRn < 0.36):
          # Encontrar la pendiente de la onda actual y la última detectada
          pendiente_actual = max(np.diff(self.ventana_mov[valor_pico - round(self.ventana_150ms/2) : valor_pico + 1]))
          pendiente_ultima = max(np.diff(self.ventana_mov[self.picos[ind_prev] - round(self.ventana_150ms/2) : self.picos[ind_prev] + 1]))

          # Si la pendiente de la onda actual es menor que la mitad de la pendiente de la última onda
          if (pendiente_actual < 0.5*pendiente_ultima):
              # Se encuentra la Onda T y se actualiza el umbral de ruido
              self.onda_T = True
              self.NPKI = 0.125 * self.ventana_mov[valor_pico] + 0.875 * self.NPKI

        if (not self.onda_T):
            # Si no se encuentra la Onda T, se actualizan los umbrales de señal
            if (self.picos_probables[ind] > self.Umbral_F1):
                self.SPKI = 0.125 * self.ventana_mov[valor_pico]  + 0.875 * self.SPKI
                self.SPKF = 0.125 * self.pasa_banda[ind] + 0.875 * self.SPKF

                # Agregar la ubicación probable del pico R
                self.r_locs.append(self.picos_probables[ind])

            else:
                self.SPKI = 0.125 * self.ventana_mov[valor_pico]  + 0.875 * self.SPKI
                self.NPKF = 0.125 * self.pasa_banda[ind] + 0.875 * self.NPKF

    # Actualizar umbrales de ruido
    elif (self.ventana_mov[valor_pico] < self.Umbral_I1) or (self.Umbral_I1 < self.ventana_mov[valor_pico] < self.Umbral_I2):
        self.NPKI = 0.125 * self.ventana_mov[valor_pico]  + 0.875 * self.NPKI
        self.NPKF = 0.125 * self.pasa_banda[ind] + 0.875 * self.NPKF


  def ajustar_umbrales(self, valor_pico, ind):
    '''
    Ajustar umbrales de ruido y señal durante la fase de aprendizaje
    :param valor_pico: ubicación del pico en consideración
    :param ind: índice actual en el array de picos
    '''

    if (self.ventana_mov[valor_pico] >= self.Umbral_I1):
        # Actualizar umbral de señal
        self.SPKI = 0.125 * self.ventana_mov[valor_pico]  + 0.875 * self.SPKI

        if (self.picos_probables[ind] > self.Umbral_F1):
            self.SPKF = 0.125 * self.pasa_banda[ind] + 0.875 * self.SPKF

            # Agregar la ubicación probable del pico R
            self.r_locs.append(self.picos_probables[ind])

        else:
            # Actualizar umbral de ruido
            self.NPKF = 0.125 * self.pasa_banda[ind] + 0.875 * self.NPKF
# Actualizar umbrales de ruido
    elif (self.ventana_mov[valor_pico] < self.Umbral_I2) or (self.Umbral_I2 < self.ventana_mov[valor_pico] < self.Umbral_I1):
        self.NPKI = 0.125 * self.ventana_mov[valor_pico]  + 0.875 * self.NPKI
        self.NPKF = 0.125 * self.pasa_banda[ind] + 0.875 * self.NPKF


  def actualizar_umbrales(self):
    '''
    Actualizar umbrales de ruido y señal para la siguiente iteración
    '''

    self.Umbral_I1 = self.NPKI + 0.25 * (self.SPKI - self.NPKI)
    self.Umbral_F1 = self.NPKF + 0.25 * (self.SPKF - self.NPKF)
    self.Umbral_I2 = 0.5 * self.Umbral_I1
    self.Umbral_F2 = 0.5 * self.Umbral_F1
    self.onda_T = False


  def retroceso_ecg(self):
    '''
    Retroceso en la señal ECG para aumentar la eficiencia
    '''

    # Filtrar las ubicaciones únicas de los picos R
    self.r_locs = np.unique(np.array(self.r_locs).astype(int))

    # Inicializar una ventana para retroceder
    ventana_200ms = round(0.2*self.frec_muestreo)

    for r_val in self.r_locs:
        coord = np.arange(r_val - ventana_200ms, min(len(self.senal), r_val + ventana_200ms + 1), 1)

        # Encontrar la ubicación x del valor máximo del pico
        if (len(coord) > 0):
          for pos in coord:
              if (self.senal[pos] == max(self.senal[coord])):
                  x_max = pos
                  break
        else:
          x_max = None
# Agregar la ubicación del pico
        if (x_max is not None):
          self.resultado.append(x_max)


  def encontrar_picos_r(self):

    # Encontrar ubicaciones aproximadas de los picos
    self.aproximar_picos()

    # Iterar sobre las posibles ubicaciones de los picos
    for ind in range(len(self.picos)):

        # Inicializar la ventana de búsqueda para la detección de picos
        valor_pico = self.picos[ind]
        ventana_300ms = np.arange(max(0, self.picos[ind] - self.ventana_150ms), min(self.picos[ind] + self.ventana_150ms, len(self.pasa_banda)-1), 1)
        valor_maximo = max(self.pasa_banda[ventana_300ms], default = 0)

        # Encontrar la ubicación x del valor máximo del pico
        if (valor_maximo != 0):
          coord_x = np.asarray(self.pasa_banda == valor_maximo).nonzero()
          self.picos_probables.append(coord_x[0][0])

        if (ind < len(self.picos_probables) and ind != 0):
            # Ajustar el intervalo RR y los límites
            self.ajustar_intervalo_rr(ind)
# Ajustar umbrales en caso de latidos irregulares
            if (self.Promedio_RR1 < self.Limite_Bajo_RR or self.Promedio_RR1 > self.Limite_RR_Perdido):
                self.Umbral_I1 /= 2
                self.Umbral_F1 /= 2

            RRn = self.RR1[-1]

            # Retroceso
            self.retroceso(valor_pico, RRn, round(RRn*self.frec_muestreo))

            # Identificación de la Onda T
            self.identificar_onda_t(valor_pico, RRn, ind, ind-1)

        else:
          # Ajustar umbrales
          self.ajustar_umbrales(valor_pico, ind)

        # Actualizar umbrales para la siguiente iteración
        self.actualizar_umbrales()

    # Retroceso en la señal ECG
    self.retroceso_ecg()

    return self.resultado

# Convertir la señal de ECG a un array numpy
senal = ecg.iloc[:,1].to_numpy()

# Encontrar las ubicaciones de los picos R
fc = frecuencia_cardiaca(senal, annotation.fs)
resultado = fc.encontrar_picos_r()
resultado = np.array(resultado)

# Recortar las ubicaciones x menores que 0 (Fase de Aprendizaje)
resultado = resultado[resultado > 0]

# Calcular la frecuencia cardíaca
frecuenciaCardiaca = (60*annotation.fs)/np.average(np.diff(resultado[1:]))
print("Frecuencia Cardíaca", frecuenciaCardiaca, "BPM")

# Graficar las ubicaciones de los picos R en la señal ECG
plt.figure(figsize = (20,4), dpi = 100)
plt.xticks(np.arange(0, len(senal)+1, 150))
plt.plot(senal, color = 'blue')
plt.scatter(resultado, senal[resultado], color = 'red', s = 100, marker= '*')
plt.xlabel('Muestras')
plt.ylabel('MLIImV')
plt.title("Ubicaciones de Picos R")